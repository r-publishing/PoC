{"version":3,"file":"rchain-did-resolver.modern.js","sources":["../src/rchain-did-resolver.ts"],"sourcesContent":["// Copyright 2018 ConsenSys AG\n\n// Licensed under the Apache License, Version 2.0(the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n\n// http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport * as rchainToolkit from 'rchain-toolkit'\nconst { readBagOrTokenDataTerm, read } = require('rchain-token')\nimport { inflate } from 'pako'\nimport * as u8a from 'uint8arrays'\nimport { ec as EC } from 'elliptic'\nconst ec = new EC('secp256k1')\n\nexport interface DIDDocument {\n  '@context': 'https://w3id.org/did/v1' | string | string[]\n  id: string\n  publicKey: PublicKey[]\n  authentication?: (string | PublicKey | Authentication)[]\n  /**\n   * @deprecated This does not appear in the did-core spec\n   */\n  uportProfile?: any\n  service?: ServiceEndpoint[]\n  /**\n   * @deprecated this property has been removed from the did-core spec\n   */\n  created?: string\n  /**\n   * @deprecated this property has been removed from the did-core spec\n   */\n  updated?: string\n  /**\n   * @deprecated this property has been removed from the did-core spec\n   */\n  proof?: LinkedDataProof\n  keyAgreement?: (string | PublicKey)[]\n}\n\nexport interface ServiceEndpoint {\n  id: string\n  type: string\n  serviceEndpoint: string\n  description?: string\n}\n\nexport interface PublicKey {\n  id: string\n  type: string\n  controller: string\n  ethereumAddress?: string\n  publicKeyBase64?: string\n  publicKeyBase58?: string\n  publicKeyHex?: string\n  publicKeyPem?: string\n}\n\n/**\n * @deprecated The `authentication` array should be an array of strings or `PublicKey`\n */\nexport interface Authentication {\n  type: string\n  publicKey: string\n}\n\nexport interface LinkedDataProof {\n  type: string\n  created: string\n  creator: string\n  nonce: string\n  signatureValue: string\n}\n\nexport interface Params {\n  [index: string]: string\n}\n\nexport interface ParsedDID {\n  did: string\n  didUrl: string\n  method: string\n  id: string\n  path?: string\n  fragment?: string\n  query?: string\n  params?: Params\n}\n\nexport type DIDResolver = (\n  did: string,\n  parsed: ParsedDID,\n  resolver: Resolver\n) => Promise<null | DIDDocument>\nexport type WrappedResolver = () => Promise<null | DIDDocument>\nexport type DIDCache = (\n  parsed: ParsedDID,\n  resolve: WrappedResolver\n) => Promise<null | DIDDocument>\n\ninterface ResolverRegistry {\n  [index: string]: DIDResolver\n}\n\nexport function inMemoryCache(): DIDCache {\n  const cache: Map<string, DIDDocument | null> = new Map()\n  return async (parsed, resolve) => {\n    if (parsed.params && parsed.params['no-cache'] === 'true')\n      return await resolve()\n\n    const cached = cache.get(parsed.did)\n    if (cached !== undefined) return cached\n    const doc = await resolve()\n    if (doc !== null) {\n      cache.set(parsed.did, doc)\n    }\n    return doc\n  }\n}\n\nexport function noCache(\n  parsed: ParsedDID,\n  resolve: WrappedResolver\n): Promise<null | DIDDocument> {\n  return resolve()\n}\n\nconst ID_CHAR = '[a-zA-Z0-9_.-]'\nconst METHOD = '([a-zA-Z0-9_]+)'\nconst METHOD_ID = `(${ID_CHAR}+(:${ID_CHAR}+)*)`\nconst PARAM_CHAR = '[a-zA-Z0-9_.:%-]'\nconst PARAM = `;${PARAM_CHAR}+=${PARAM_CHAR}*`\nconst PARAMS = `((${PARAM})*)`\nconst PATH = `(\\/[^#?]*)?`\nconst QUERY = `([?][^#]*)?`\nconst FRAGMENT = `(\\#.*)?`\nconst DID_MATCHER = new RegExp(\n  `^did:${METHOD}:${METHOD_ID}${PARAMS}${PATH}${QUERY}${FRAGMENT}$`\n)\nexport function parse(didUrl: string): ParsedDID {\n  if (didUrl === '' || !didUrl) throw new Error('Missing DID')\n  const sections = didUrl.match(DID_MATCHER)\n  if (sections) {\n    const parts: ParsedDID = {\n      did: `did:${sections[1]}:${sections[2]}`,\n      method: sections[1],\n      id: sections[2],\n      didUrl\n    }\n    if (sections[4]) {\n      const params = sections[4].slice(1).split(';')\n      parts.params = {}\n      for (const p of params) {\n        const kv = p.split('=')\n        parts.params[kv[0]] = kv[1]\n      }\n    }\n    if (sections[6]) parts.path = sections[6]\n    if (sections[7]) parts.query = sections[7].slice(1)\n    if (sections[8]) parts.fragment = sections[8].slice(1)\n    return parts\n  }\n  throw new Error(`Invalid DID ${didUrl}`)\n}\n\nexport class Resolver {\n  private registry: ResolverRegistry\n  private cache: DIDCache\n\n  constructor(\n    registry: ResolverRegistry = {},\n    cache?: DIDCache | boolean | undefined\n  ) {\n    this.registry = registry\n    this.cache = cache === true ? inMemoryCache() : cache || noCache\n  }\n\n  async resolve(didUrl: string): Promise<DIDDocument> {\n    const parsed = parse(didUrl)\n    const resolver = this.registry[parsed.method]\n    if (resolver) {\n      const doc = await this.cache(parsed, () =>\n        resolver(parsed.did, parsed, this)\n      )\n      if (doc == null) {\n        throw new Error(`resolver returned null for ${parsed.did}`)\n      } else {\n        return doc\n      }\n    }\n    throw new Error(`Unsupported DID method: '${parsed.method}'`)\n  }\n}\n\nexport function encodeDIDFromPubKey(publicKey: string): string {\n  const pubBytes = ec.keyFromPublic(publicKey, 'hex').getPublic(true, 'array')\n  const bytes = new Uint8Array(pubBytes.length + 2)\n  bytes[0] = 0xe7 // secp256k1 multicodec\n  // The multicodec is encoded as a varint so we need to add this.\n  // See js-multicodec for a general implementation\n  bytes[1] = 0x01\n  bytes.set(pubBytes, 2)\n  return `did:key:z${u8a.toString(bytes, 'base58btc')}`\n}\n\nexport function getResolver() {\n  async function resolve(\n    did: string,\n    parsed: ParsedDID,\n    didResolver: Resolver\n  ): Promise<any> {\n    let term\n\n    if (parsed.path && parsed.path !== '') {\n      term = readBagOrTokenDataTerm(\n        parsed.id,\n        'bags',\n        parsed.path?.substring(1)\n      )\n    } else {\n      term = read(parsed.id)\n    }\n\n    const ed = await rchainToolkit.http.exploreDeploy(\n      'http://localhost:40403',\n      {\n        term: term\n      }\n    )\n\n    if (parsed.path && parsed.path !== '') {\n      let fileAsJson: any = {}\n      try {\n        const dataAtNameBuffer = Buffer.from(\n          decodeURI(rchainToolkit.utils.rhoValToJs(JSON.parse(ed).expr[0])),\n          'base64'\n        )\n        const unzippedBuffer = Buffer.from(inflate(dataAtNameBuffer))\n        const fileAsString = unzippedBuffer.toString('utf-8')\n        fileAsJson = JSON.parse(fileAsString)\n      } finally {\n      }\n      // If you need to lookup another did as part of resolving this did document, the primary DIDResolver object is passed in as well\n      //const parentDID = await didResolver.resolve(...)\n      //\n      return fileAsJson\n    } else {\n      const contractData = rchainToolkit.utils.rhoValToJs(\n        JSON.parse(ed).expr[0]\n      )\n      const did = encodeDIDFromPubKey(contractData.publicKey)\n      const keyid = did.substr(8)\n      const did2 = did + '#' + keyid\n\n      const ret = {\n        id: did,\n        publicKey: [\n          {\n            id: did2,\n            type: 'Secp256k1VerificationKey2018',\n            controller: did2,\n            publicKeyHex: contractData.publicKey\n          } as PublicKey\n        ]\n      } as DIDDocument\n\n      return ret\n    }\n  }\n\n  return { rchain: resolve }\n}\n"],"names":["readBagOrTokenDataTerm","read","require","ec","EC","inMemoryCache","cache","Map","parsed","resolve","params","cached","get","did","undefined","doc","set","noCache","DID_MATCHER","RegExp","parse","didUrl","Error","sections","match","parts","method","id","slice","split","p","kv","path","query","fragment","Resolver","constructor","registry","this","[object Object]","resolver","encodeDIDFromPubKey","publicKey","pubBytes","keyFromPublic","getPublic","bytes","Uint8Array","length","u8a","getResolver","rchain","async","didResolver","term","_parsed$path","substring","ed","rchainToolkit","exploreDeploy","fileAsJson","dataAtNameBuffer","Buffer","from","decodeURI","rhoValToJs","JSON","expr","fileAsString","inflate","toString","contractData","keyid","substr","did2","type","controller","publicKeyHex"],"mappings":"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"}